[genesis]
# Human readable name for convenience; the genesis_hash is the true identifier.  The name influences the genesis hash by
# contributing to the seeding of the pseudo-random number generator used in contract-runtime for computing genesis
# post-state hash.
name = 'casper-charlie-testnet-1'
# Timestamp for the genesis block, also used in seeding the pseudo-random number generator used in contract-runtime for
# computing genesis post-state hash.
timestamp = '2020-09-18T18:45:00Z'
# Protocol version at genesis.
protocol_version = '1.0.0'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the mint
# system contract.
mint_installer_path = '/etc/casper/wasm/mint_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Proof of
# Stake system contract.
pos_installer_path = '/etc/casper/wasm/pos_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Standard
# Payment system contract.
standard_payment_installer_path = '/etc/casper/wasm/standard_payment_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Auction
# system contract.
auction_installer_path = '/etc/casper/wasm/auction_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the CSV file containing initial account balances and bonds.
accounts_path = '/etc/casper/accounts.csv'
# Number of slots available in validator auction.
validator_slots = 15

[highway]
# Beginning of era 0. By this time, a sufficient majority (> 50% + F/2 â€” see finality_threshold_percent below)
# of validator nodes must be up and running to start the blockchain.
genesis_era_start_timestamp = '2020-09-18T18:45:00Z'
# Era duration.
era_duration = '30minutes'
# Minimum number of blocks per era.  An era will take longer than `era_duration` if that is necessary to reach the
# minimum height.
minimum_era_height = 10
# Amount of time to go back before the start of the era for picking the booking block.
booking_duration = '0ms'
# Amount of time to wait after the booking before we pick the key block, collecting the magic bits along the way.
entropy_duration = '0ms'
# Keep voting on the switch block for a fixed amount of time; effective if the summit level is zero.
voting_period_duration = '2days'
# Integer between 1 and 99 representing the fault tolerance threshold as a percentage, used by the internal finalizer.
# It is the percentage of validators that would need to equivocate to make two honest nodes see two conflicting
# blocks as finalized: A higher value F makes it safer to rely on finalized blocks. It also makes it more difficult to
# finalize blocks, however, and requires strictly more than 50% + F/2 validators to be working correctly.
finality_threshold_percent = 10
# Integer between 0 and 255. The power of two that is the number of milliseconds in the minimum round length, and
# therefore the minimum delay between a block and its child. E.g. 14 means 2^14 milliseconds, i.e. about 16 seconds.
minimum_round_exponent = 17

[deploys]
# The maximum number of Motes allowed to be spent during payment.  0 means unlimited.
max_payment_cost = '0'
# The duration after the deploy timestamp that it can be included in a block.
max_ttl = '1day'
# The maximum number of other deploys a deploy can depend on (require to have been executed before it can execute).
max_dependencies = 10
# Maximum block size in bytes.  0 means unlimited.
max_block_size = 10_485_760
# The maximum number of deploys permitted in a single block.
block_max_deploy_count = 10
# The upper limit of total gas of all deploys in a block.
block_gas_limit = 10_000_000_000_000

[wasm_config]
# Amount of free memory (in 64kB pages) each contract can use for stack.
initial_memory = 64
# Max stack height (native WebAssembly stack limiter).
max_stack_height = 65536

[wasm_config.opcode_costs]
# Bit operations multiplier.
bit = 300_000
# Arithmetic add operations multiplier.
add = 210_000
# Mul operations multiplier.
mul = 240_000
# Div operations multiplier.
div = 320_000
# Memory load operation multiplier.
load = 2_500_000
# Memory store operation multiplier.
store = 4_700_000
# Const store operation multiplier.
const = 110_000
# Local operations multiplier.
local = 390_000
# Global operations multiplier.
global = 390_000
# Control flow operations multiplier.
control_flow = 440_000
# Integer operations multiplier.
integer_comparsion = 250_000
# Conversion operations multiplier.
conversion = 420_000
# Unreachable operation multiplier.
unreachable = 270_000
# Nop operation multiplier.
nop = 1
# Get current memory operation multiplier.
current_memory = 290_000
# Grow memory cost, per page (64kb)
grow_memory = 240_000_000
# Regular opcode cost
regular = 210_000

[wasm_config.storage_costs]
# Gas charged per byte stored in the global state.
gas_per_byte = 630_000_000

# Host function declarations are located in smart_contracts/contract/src/ext_ffi.rs
[wasm_config.host_function_costs]
add = { cost = 5_800_000, arguments = [0, 1, 2, 3] }
add_associated_key = { cost = 9_000_000, arguments = [0, 1, 2, 3] }
add_contract_version = { cost = 200_000_000, arguments = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] } # Not instrumented yet, assuming a sufficiently large number
add_local = { cost = 4_700_000, arguments = [810], arguments = [0, 1, 2, 3] }
call_contract = { cost = 4_500_000, arguments = [421], arguments = [0, 1, 2, 3, 4, 5, 6] }
call_versioned_contract = { cost = 4_500_000, arguments = [0, 1, 2, 3, 4, 5, 6, 7, 8] } # Not instrumented yet, assuming the same as call_contract
create_contract_package_at_hash = { cost = 200_000_000, arguments = [0, 1] } # Not instrumented yet, assuming a sufficiently large number
create_contract_user_group = { cost = 200_000_000, arguments = [0, 1, 2, 3, 4, 5, 6, 7] } # Not instrumented yet, assuming a sufficiently large number
create_purse = { cost = 170_000_000, arguments = [0, 1] }
disable_contract_version = { cost = 200_000_000, arguments = [0, 1, 2, 3] } # Not instrumented yet, assuming a sufficiently large number
get_balance = { cost = 3_800_000, arguments = [0, 1, 2] }
get_blocktime = { cost = 330_000, arguments = [0] }
get_caller = { cost = 380_000, arguments = [0] }
get_key = { cost = 2_000_000, arguments = [0, 1, 2, 3, 4] }
get_main_purse = { cost = 1_300_000, arguments = [0] }
get_named_arg = { cost = 2_500_000, arguments = [0, 1, 2, 3] }
get_named_arg_size = { cost = 450_000, arguments = [0, 1, 2] }
get_phase = { cost = 710_000, arguments = [0] }
get_system_contract = { cost = 1_100_000, arguments = [0, 1, 2] }
has_key = { cost = 1_500_000, arguments = [840], arguments = [0, 1] }
is_valid_uref = { cost = 760_000, arguments = [0, 1] }
load_named_keys = { cost = 42_000_000, arguments = [0, 1] }
new_uref = { cost = 17_000_000, arguments = [0, 1, 2] }
print = { cost = 20_000_000, arguments = [0, 1] }
provision_contract_user_group_uref = { cost = 200_000_000, arguments = [0,1,2,3,4] } # Not instrumented yet, assuming a sufficiently large number
put_key = { cost = 38_000_000, arguments = [0, 1] }
read_host_buffer = { cost = 3_500_000, arguments = [0, 1, 2] }
read_value = { cost = 6_000_000, arguments = [0, 1, 0] }
read_value_local = { cost = 5_500_000,  arguments = [0, 1, 0] }
remove_associated_key = { cost = 4_200_000, arguments = [0, 1] }
remove_contract_user_group = { cost = 200_000_000, arguments = [0, 1, 2, 3] } # Not instrumented yet, assuming a sufficiently large number
remove_contract_user_group_urefs = { cost = 200_000_000, arguments = [0,1,2,3,4,5] } # Not instrumented yet, assuming a sufficiently large number
remove_key = { cost = 61_000_000, arguments = [0, 1] }
ret = { cost = 23_000_000, arguments = [0, 1] }
revert = { cost = 500_000, arguments = [0] }
set_action_threshold = { cost = 74_000_000, arguments = [0, 1] }
transfer_from_purse_to_account = { cost = 160_000_000, arguments = [0, 1, 2, 3, 4, 5] }
transfer_from_purse_to_purse = { cost = 82_000_000, arguments = [0, 1, 2, 3, 4, 5] }
transfer_to_account = { cost = 24_000_000, arguments = [0, 1, 2, 3] }
update_associated_key = { cost = 4_200_000, arguments = [0, 1, 2] }
write = { cost = 14_000_000,  arguments = [0, 1, 0, 2] }
write_local = { cost = 9_500_000, arguments = [0, 1, 2, 3] }
