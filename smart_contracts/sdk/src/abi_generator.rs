use std::{ffi::c_void, ptr::NonNull};

use crate::{abi::Declaration, linkme::distributed_slice};

#[derive(Debug)]
pub struct Param {
    pub name: &'static str,
    pub decl: Declaration,
}

#[derive(Debug)]
pub struct EntryPoint {
    pub name: &'static str,
    pub params: &'static [&'static Param],
    pub result_decl: Declaration,
}

pub struct Manifest {
    pub name: &'static str,
    pub entry_points: &'static [EntryPoint],
}

/// All of the entry points generated by proc macro will be registered here.
#[distributed_slice]
#[linkme(crate = crate::linkme)]
pub static ENTRYPOINTS: [fn() -> crate::schema::SchemaEntryPoint] = [..];

#[distributed_slice]
#[linkme(crate = crate::linkme)]
pub static ABI_COLLECTORS: [fn(&mut crate::abi::Definitions)] = [..];

#[no_mangle]
pub extern "C" fn __cargo_casper_load_entrypoints(
    callback: extern "C" fn(*const crate::schema::SchemaEntryPoint, usize, *mut c_void),
    ctx: *mut c_void,
) {
    let mut vec = Vec::new();
    for entrypoint in ENTRYPOINTS {
        let entrypoint = entrypoint();
        vec.push(entrypoint);
    }
    callback(vec.as_ptr(), vec.len(), ctx);
}

#[no_mangle]
pub extern "C" fn __cargo_casper_collect_abi(definitions: *mut crate::abi::Definitions) {
    let mut ptr = NonNull::new(definitions).expect("non-null pointer");
    for collector in ABI_COLLECTORS {
        collector(unsafe { ptr.as_mut() });
    }
}
