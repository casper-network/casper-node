mod transaction_v1_body {
    use alloc::vec::Vec;
    use core::fmt::{self, Display, Formatter};
    use super::super::{
        RuntimeArgs, TransactionEntryPoint, TransactionScheduling, TransactionTarget,
    };
    use super::TransactionCategory;
    use crate::{
        bytesrepr::{self, ToBytes},
        transaction::serialization::{BinaryPayload, CalltableFromBytes, CalltableToBytes},
    };
    use macros::{CalltableFromBytes, CalltableToBytes};
    /// The body of a [`TransactionV1`].
    pub struct TransactionV1Body {
        #[calltable(field_index = 0)]
        pub(crate) args: RuntimeArgs,
        #[calltable(field_index = 1)]
        pub(crate) target: TransactionTarget,
        #[calltable(field_index = 2)]
        pub(crate) entry_point: TransactionEntryPoint,
        #[calltable(field_index = 3)]
        pub(crate) transaction_category: u8,
        #[calltable(field_index = 4)]
        pub(crate) scheduling: TransactionScheduling,
    }
    impl CalltableToBytes for TransactionV1Body {
        fn serialized_field_lengths(&self) -> Vec<usize> {
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    self.args.serialized_length(),
                    self.target.serialized_length(),
                    self.entry_point.serialized_length(),
                    self.transaction_category.serialized_length(),
                    self.scheduling.serialized_length(),
                ]),
            )
        }
        fn serialize(&self) -> Result<Vec<u8>, crate::bytesrepr::Error> {
            crate::transaction::serialization::BinaryPayloadBuilder::new(
                    self.serialized_field_lengths(),
                )?
                .add_field(0u16, &self.args)?
                .add_field(1u16, &self.target)?
                .add_field(2u16, &self.entry_point)?
                .add_field(3u16, &self.transaction_category)?
                .add_field(4u16, &self.scheduling)?
                .binary_payload_bytes()
        }
    }
    impl crate::bytesrepr::ToBytes for TransactionV1Body {
        fn to_bytes(&self) -> Result<Vec<u8>, crate::bytesrepr::Error> {
            CalltableToBytes::serialize(self)
        }
        fn serialized_length(&self) -> usize {
            BinaryPayload::estimate_size(self.serialized_field_lengths())
        }
    }
    impl CalltableFromBytes for TransactionV1Body {
        fn from_bytes(
            bytes: &[u8],
        ) -> Result<(TransactionV1Body, &[u8]), crate::bytesrepr::Error> {
            let (binary_payload, remainder) = crate::transaction::serialization::BinaryPayload::from_bytes(
                5u32,
                bytes,
            )?;
            let window = binary_payload.start_consuming()?;
            let window = window.ok_or(bytesrepr::Error::Formatting)?;
            window.verify_index(0u16)?;
            let (args, window) = window.deserialize_and_maybe_next::<RuntimeArgs>()?;
            let window = window.ok_or(bytesrepr::Error::Formatting)?;
            window.verify_index(1u16)?;
            let (target, window) = window
                .deserialize_and_maybe_next::<TransactionTarget>()?;
            let window = window.ok_or(bytesrepr::Error::Formatting)?;
            window.verify_index(2u16)?;
            let (entry_point, window) = window
                .deserialize_and_maybe_next::<TransactionEntryPoint>()?;
            let window = window.ok_or(bytesrepr::Error::Formatting)?;
            window.verify_index(3u16)?;
            let (transaction_category, window) = window
                .deserialize_and_maybe_next::<u8>()?;
            let window = window.ok_or(bytesrepr::Error::Formatting)?;
            window.verify_index(4u16)?;
            let (scheduling, window) = window
                .deserialize_and_maybe_next::<TransactionScheduling>()?;
            if window.is_some() {
                return Err(bytesrepr::Error::Formatting);
            }
            let from_bytes = TransactionV1Body {
                args,
                target,
                entry_point,
                transaction_category,
                scheduling,
            };
            Ok((from_bytes, remainder))
        }
    }
    impl crate::bytesrepr::FromBytes for TransactionV1Body {
        fn from_bytes(bytes: &[u8]) -> Result<(Self, &[u8]), crate::bytesrepr::Error> {
            CalltableFromBytes::from_bytes(bytes)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransactionV1Body {
        #[inline]
        fn clone(&self) -> TransactionV1Body {
            TransactionV1Body {
                args: ::core::clone::Clone::clone(&self.args),
                target: ::core::clone::Clone::clone(&self.target),
                entry_point: ::core::clone::Clone::clone(&self.entry_point),
                transaction_category: ::core::clone::Clone::clone(
                    &self.transaction_category,
                ),
                scheduling: ::core::clone::Clone::clone(&self.scheduling),
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TransactionV1Body {
        #[inline]
        fn cmp(&self, other: &TransactionV1Body) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.target, &other.target) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.entry_point,
                                &other.entry_point,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.transaction_category,
                                        &other.transaction_category,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.scheduling, &other.scheduling)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TransactionV1Body {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TransactionV1Body,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.args, &other.args) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.target,
                        &other.target,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.entry_point,
                                &other.entry_point,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.transaction_category,
                                        &other.transaction_category,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.scheduling,
                                                &other.scheduling,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TransactionV1Body {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<RuntimeArgs>;
            let _: ::core::cmp::AssertParamIsEq<TransactionTarget>;
            let _: ::core::cmp::AssertParamIsEq<TransactionEntryPoint>;
            let _: ::core::cmp::AssertParamIsEq<u8>;
            let _: ::core::cmp::AssertParamIsEq<TransactionScheduling>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TransactionV1Body {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TransactionV1Body {
        #[inline]
        fn eq(&self, other: &TransactionV1Body) -> bool {
            self.args == other.args && self.target == other.target
                && self.entry_point == other.entry_point
                && self.transaction_category == other.transaction_category
                && self.scheduling == other.scheduling
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TransactionV1Body {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.target, state);
            ::core::hash::Hash::hash(&self.entry_point, state);
            ::core::hash::Hash::hash(&self.transaction_category, state);
            ::core::hash::Hash::hash(&self.scheduling, state)
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransactionV1Body {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "TransactionV1Body",
                "args",
                &self.args,
                "target",
                &self.target,
                "entry_point",
                &self.entry_point,
                "transaction_category",
                &self.transaction_category,
                "scheduling",
                &&self.scheduling,
            )
        }
    }
    pub struct A {
        #[calltable(field_index = 0)]
        pub(crate) field1: u8,
        #[calltable(field_index = 1)]
        pub(crate) field2: u8,
    }
    impl CalltableToBytes for A {
        fn serialized_field_lengths(&self) -> Vec<usize> {
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    self.field1.serialized_length(),
                    self.field2.serialized_length(),
                ]),
            )
        }
        fn serialize(&self) -> Result<Vec<u8>, crate::bytesrepr::Error> {
            crate::transaction::serialization::BinaryPayloadBuilder::new(
                    self.serialized_field_lengths(),
                )?
                .add_field(0u16, &self.field1)?
                .add_field(1u16, &self.field2)?
                .binary_payload_bytes()
        }
    }
    impl crate::bytesrepr::ToBytes for A {
        fn to_bytes(&self) -> Result<Vec<u8>, crate::bytesrepr::Error> {
            CalltableToBytes::serialize(self)
        }
        fn serialized_length(&self) -> usize {
            BinaryPayload::estimate_size(self.serialized_field_lengths())
        }
    }
    impl TransactionV1Body {
        /// Returns a new `TransactionV1Body`.
        pub fn new(
            args: RuntimeArgs,
            target: TransactionTarget,
            entry_point: TransactionEntryPoint,
            transaction_category: u8,
            scheduling: TransactionScheduling,
        ) -> Self {
            TransactionV1Body {
                args,
                target,
                entry_point,
                transaction_category,
                scheduling,
            }
        }
        /// Returns the runtime args of the transaction.
        pub fn args(&self) -> &RuntimeArgs {
            &self.args
        }
        /// Consumes `self`, returning the runtime args of the transaction.
        pub fn take_args(self) -> RuntimeArgs {
            self.args
        }
        /// Returns the target of the transaction.
        pub fn target(&self) -> &TransactionTarget {
            &self.target
        }
        /// Returns the entry point of the transaction.
        pub fn entry_point(&self) -> &TransactionEntryPoint {
            &self.entry_point
        }
        /// Returns the scheduling kind of the transaction.
        pub fn scheduling(&self) -> &TransactionScheduling {
            &self.scheduling
        }
        /// Returns true if this transaction is a native mint interaction.
        pub fn is_native_mint(&self) -> bool {
            self.transaction_category == TransactionCategory::Mint as u8
        }
        /// Returns true if this transaction is a native auction interaction.
        pub fn is_native_auction(&self) -> bool {
            self.transaction_category == TransactionCategory::Auction as u8
        }
        /// Returns true if this transaction is a smart contract installer or upgrader.
        pub fn is_install_or_upgrade(&self) -> bool {
            self.transaction_category == TransactionCategory::InstallUpgrade as u8
        }
        /// Returns the transaction category.
        pub fn transaction_category(&self) -> u8 {
            self.transaction_category
        }
        /// Consumes `self`, returning its constituent parts.
        pub fn destructure(
            self,
        ) -> (
            RuntimeArgs,
            TransactionTarget,
            TransactionEntryPoint,
            TransactionScheduling,
        ) {
            (self.args, self.target, self.entry_point, self.scheduling)
        }
    }
    impl Display for TransactionV1Body {
        fn fmt(&self, formatter: &mut Formatter) -> fmt::Result {
            formatter
                .write_fmt(
                    format_args!(
                        "v1-body({0} {1} {2})",
                        self.target,
                        self.entry_point,
                        self.scheduling,
                    ),
                )
        }
    }
}
